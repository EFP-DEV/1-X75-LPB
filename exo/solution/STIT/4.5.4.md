# Exercice 4.5 — Version 4 (un autre candidat peut aussi gagner)

## Introduction

Reprenons la version 3 et testons-la avec un jeu de valeurs qu'on n'a pas encore essayé.

---

## Le cas oublié

### Exemple — s1 = 30, s2 = 55, s3 = 10, s4 = 5

Déroulons la version 3 :

* `s1 > 50` : faux (30 ≤ 50)
* `s1 < 12,5` : faux (30 ≥ 12,5)
* `s1 >= s2` : faux (30 < 55)
* → **ballottage défavorable**

Mais le candidat 2 a **55 %**. Il est **élu au premier tour**. Il n'y a **pas** de second tour.

Le candidat 1 n'est pas en ballottage : il est **battu**. Il a perdu l'élection.

---

## Pourquoi la version 3 se trompe

La version 3 teste si le candidat 1 a moins de 12,5 % pour décider s'il est battu. Mais ce n'est pas la seule façon d'être battu.

On est aussi battu si **un autre candidat a déjà gagné** (> 50 %).

Avoir 12,5 % ou plus ne suffit pas pour être en ballottage : encore faut-il qu'il **y ait** un second tour.

---

## Quand y a-t-il un second tour ?

Il y a un second tour **si et seulement si** aucun candidat n'a strictement plus de 50 %.

Si un candidat quelconque a > 50 %, il est élu et le candidat 1 est soit cet élu (déjà traité), soit battu.

---

## Pseudo-code (Version 4)

```
1   Variables s1, s2, s3, s4 en Décimal
2
3   Début
4       Lire s1
5       Lire s2
6       Lire s3
7       Lire s4
8
9       Si s1 > 50 Alors
10          Ecrire "élu"
11      SinonSi s2 > 50 OU s3 > 50 OU s4 > 50 Alors
12          Ecrire "battu"
13      SinonSi s1 < 12,5 Alors
14          Ecrire "battu"
15      SinonSi s1 >= s2 ET s1 >= s3 ET s1 >= s4 Alors
16          Ecrire "ballottage favorable"
17      Sinon
18          Ecrire "ballottage défavorable"
19      FinSi
20  Fin
```

---

## Remarque sur l'ordre des tests

1. D'abord : est-ce que **le candidat 1** a gagné ? (s1 > 50)
2. Ensuite : est-ce qu'**un autre** a gagné ? (s2/s3/s4 > 50) → pas de second tour → battu
3. Ensuite : est-ce que le candidat 1 est éliminé ? (s1 < 12,5) → battu
4. Sinon : il y a un second tour et le candidat 1 y participe → favorable ou défavorable

Les lignes 11–12 et 13–14 produisent le même message ("battu"), mais pour des raisons **différentes** :

* ligne 11 : battu parce qu'un autre a gagné
* ligne 13 : battu parce qu'il n'a pas assez de voix pour se qualifier

On pourrait les regrouper en une seule condition avec `OU`, mais les séparer rend la logique plus lisible.

---

## Inspection des valeurs

### Exemple 1 — s1 = 55, s2 = 20, s3 = 15, s4 = 10

* `s1 > 50` : vrai → **élu** ✓

### Exemple 2 — s1 = 30, s2 = 55, s3 = 10, s4 = 5

* `s1 > 50` : faux
* `s2 > 50` : vrai → **battu** ✓ (le candidat 2 a gagné, pas de second tour)

### Exemple 3 — s1 = 8, s2 = 40, s3 = 30, s4 = 22

* `s1 > 50` : faux
* `s2 > 50 OU s3 > 50 OU s4 > 50` : faux
* `s1 < 12,5` : vrai → **battu** ✓ (éliminé, pas assez de voix)

### Exemple 4 — s1 = 35, s2 = 30, s3 = 20, s4 = 15

* `s1 > 50` : faux
* aucun autre > 50 : faux
* `s1 < 12,5` : faux
* `s1 >= s2 ET s1 >= s3 ET s1 >= s4` : vrai → **ballottage favorable** ✓

### Exemple 5 — s1 = 20, s2 = 35, s3 = 25, s4 = 20

* `s1 > 50` : faux
* aucun autre > 50 : faux
* `s1 < 12,5` : faux
* `s1 >= s2` : faux → **ballottage défavorable** ✓

### Exemple 6 (égalité) — s1 = 25, s2 = 25, s3 = 25, s4 = 25

* `s1 > 50` : faux
* aucun autre > 50 : faux
* `s1 < 12,5` : faux
* `s1 >= s2` : vrai, `s1 >= s3` : vrai, `s1 >= s4` : vrai → **ballottage favorable** ✓

---

## Leçon

Tester uniquement les propriétés du candidat 1 (son score) ne suffit pas. Il faut aussi prendre en compte **ce que font les autres**.

C'est un piège classique : on se concentre sur le sujet de l'énoncé ("la situation du candidat n°1") et on oublie que sa situation **dépend** des autres.

---

## Pourquoi on ne le voit pas

Un être humain normal, en lisant "analyser la situation du candidat 1", pense au candidat 1. Son score, ses chances, ses seuils. C'est naturel : le sujet de la phrase, c'est lui.

Personne ne se dit spontanément : "et si un autre candidat avait déjà gagné ?". On ne pense pas aux cas qu'on ne nous demande pas de regarder. On raisonne sur le sujet, pas sur le contexte.

## Pourquoi un développeur le voit

Un développeur ne lit pas un énoncé comme un texte. Il le lit comme une **spécification incomplète**.

Sa question réflexe n'est pas "qu'est-ce qu'on me demande ?". C'est : "**qu'est-ce qui peut se passer d'autre ?**"

Il cherche les cas limites, les combinaisons imprévues, les hypothèses implicites. Pas par pessimisme : par habitude. Parce qu'un programme, contrairement à un humain, ne "comprend" pas le contexte. Il exécute exactement ce qu'on lui a écrit — et rien d'autre.

Un humain devant un bulletin de vote à 55 % sait que l'élection est finie. Un programme qui ne teste que `s1` ne le sait pas.

## Pourquoi c'est utile au-delà du code

Cette habitude de chercher les cas oubliés, les hypothèses implicites, les scénarios que personne n'a mentionnés — c'est ce qui rend un développeur utile dans une réunion, dans une rédaction de contrat, dans un projet.

Ce n'est pas une compétence technique. C'est une façon de penser : **ne pas faire confiance à l'évidence**.

---

## Conclusion

La version 4 corrige le dernier défaut : elle vérifie qu'aucun autre candidat n'a gagné avant de parler de ballottage.

L'algorithme final couvre les quatre issues :

* **élu** : s1 > 50
* **battu** : un autre > 50, ou s1 < 12,5
* **ballottage favorable** : personne > 50, s1 ≥ 12,5, et s1 en tête (égalité incluse)
* **ballottage défavorable** : personne > 50, s1 ≥ 12,5, mais pas en tête