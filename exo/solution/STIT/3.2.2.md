## Intermédiaire d’analyse

### 1) Constat après la version 1

La version 1 fonctionne, mais elle est interdite par la contrainte, car elle calcule :

* `p <- a * b`

Or l’énoncé dit : on ne doit pas calculer le produit.

Donc il faut trouver une méthode qui donne le signe du produit sans faire la multiplication.

---

### 2) Recherche empirique (par essais)

Pour découvrir une règle, on peut tester quelques cas simples sur papier, uniquement pour observer le signe :

|  a |  b | signe de a*b |
| -: | -: | ------------ |
|  2 |  3 | positif      |
| -2 |  3 | négatif      |
|  2 | -3 | négatif      |
| -2 | -3 | positif      |

Observation :

* quand les deux signes sont identiques (`+ +` ou `- -`) le résultat est positif ;
* quand les signes sont différents (`+ -` ou `- +`) le résultat est négatif.

On peut donc formuler une règle.

---

### 3) Règle trouvée

Le signe du produit dépend uniquement des signes de `a` et `b` :

* même signe → produit positif
* signes différents → produit négatif

Cela permet de respecter la contrainte : on n’a pas besoin de multiplier.

---

### 4) Traduction de la règle en conditions logiques

Pour exprimer “même signe” en pseudo-code, on compare chaque nombre à 0 :

* “a est positif” : `a > 0`
* “a est négatif” : `a < 0`
* “b est positif” : `b > 0`
* “b est négatif” : `b < 0`

“Même signe” correspond à deux situations possibles :

1. les deux sont positifs : `a > 0 ET b > 0`
2. les deux sont négatifs : `a < 0 ET b < 0`

Donc la condition complète devient :

`(a > 0 ET b > 0) OU (a < 0 ET b < 0)`

Si cette condition est vraie, le produit est positif, sinon il est négatif.

---

### 5) Remarque sur le cas du zéro

Si `a = 0` ou `b = 0`, le produit est nul.

L’énoncé dit qu’on ignore ce cas : on suppose donc que l’utilisateur ne saisit pas 0 (ou qu’on n’a pas à gérer ce cas dans cette version).

Cela explique pourquoi la version 2 peut utiliser un `Sinon` : le `Sinon` représente ici “signes différents”, à condition que 0 n’apparaisse pas.
